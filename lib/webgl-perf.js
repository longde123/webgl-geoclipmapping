// Generated by CoffeeScript 1.8.0
(function() {
  var Graph, css, element, formatNum;

  css = function(elem, values) {
    var name, value, _results;
    _results = [];
    for (name in values) {
      value = values[name];
      if (typeof value === 'number') {
        _results.push(elem.style[name] = value.toFixed(0) + 'px');
      } else {
        _results.push(elem.style[name] = value);
      }
    }
    return _results;
  };

  element = function(parent, name, style) {
    var elem;
    elem = document.createElement(name);
    css(elem, style);
    parent.appendChild(elem);
    return elem;
  };

  formatNum = function(n) {
    if (n < 1000) {
      return n.toFixed(1);
    } else if (n < 1000000) {
      return (n / 1000).toFixed(1) + 'k';
    } else {
      return (n / 1000000).toFixed(1) + 'm';
    }
  };

  Graph = (function() {
    function Graph(label, container) {
      var graphHeight, graphWidth, i, labelHeight, legendWidth, totalHeight, totalWidth, _i, _ref;
      this.width = 160;
      this.values = new Float32Array(this.width);
      this.idx = 0;
      for (i = _i = 0, _ref = this.values.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.values[i] = NaN;
      }
      graphHeight = this.height = 40;
      graphWidth = this.width;
      legendWidth = 50;
      labelHeight = 15;
      totalWidth = graphWidth + legendWidth;
      totalHeight = graphHeight + labelHeight;
      this.container = element(container, 'div', {
        width: totalWidth,
        height: totalHeight,
        display: 'inline-block',
        position: 'relative',
        marginLeft: 5,
        marginTop: 5
      });
      this.label = element(this.container, 'div', {
        width: totalWidth,
        height: labelHeight,
        position: 'absolute',
        top: 0,
        left: 0,
        fontSize: labelHeight * 0.8,
        lineHeight: labelHeight
      });
      this.label.textContent = label;
      this.legend = element(this.container, 'div', {
        width: legendWidth,
        height: graphHeight,
        position: 'absolute',
        top: labelHeight,
        left: 0
      });
      this.max = element(this.legend, 'div', {
        width: legendWidth - 5,
        height: graphHeight / 3,
        lineHeight: graphHeight / 3,
        textAlign: 'right',
        paddingRight: 5
      });
      this.max.textContent = 'max';
      this.avg = element(this.legend, 'div', {
        width: legendWidth - 5,
        height: graphHeight / 3,
        lineHeight: graphHeight / 3,
        textAlign: 'right',
        paddingRight: 5
      });
      this.avg.textContent = 'avg';
      this.min = element(this.legend, 'div', {
        width: legendWidth - 5,
        height: graphHeight / 3,
        lineHeight: graphHeight / 3,
        textAlign: 'right',
        paddingRight: 5
      });
      this.min.textContent = 'min';
      this.canvas = element(this.container, 'canvas', {
        width: graphWidth,
        height: graphHeight,
        position: 'absolute',
        top: labelHeight,
        left: legendWidth,
        background: 'linear-gradient(to bottom, rgba(0,255,0,0.3) 0%,rgba(0,255,0,0.1) 100%)'
      });
      this.canvas.width = graphWidth;
      this.canvas.height = graphHeight;
      this.ctx = this.canvas.getContext('2d');
      this.ctx.transform(1, 0, 0, -1, 0, this.height);
    }

    Graph.prototype.add = function(value) {
      if (value == null) {
        value = this.counter;
      }
      this.values[this.idx] = value;
      return this.idx = (this.idx + 1) % this.width;
    };

    Graph.prototype.draw = function() {
      var avg, diff, f, i, left, max, min, value, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3;
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.ctx.strokeStyle = 'red';
      min = max = this.values[0];
      avg = 0;
      _ref = this.values;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        value = _ref[_i];
        if (!isNaN(value)) {
          min = Math.min(value, min);
          max = Math.max(value, max);
          avg += value;
        }
      }
      avg /= this.width;
      this.avg.textContent = formatNum(avg);
      this.min.textContent = formatNum(min);
      this.max.textContent = formatNum(max);
      this.ctx.beginPath();
      diff = max - min;
      if (diff > 0) {
        if (!isNaN(this.values[this.idx])) {
          for (i = _j = _ref1 = this.idx, _ref2 = this.width; _ref1 <= _ref2 ? _j < _ref2 : _j > _ref2; i = _ref1 <= _ref2 ? ++_j : --_j) {
            f = (this.values[i] - min) / diff;
            left = i - this.idx;
            this.ctx.lineTo(left, this.height * f);
          }
        }
        for (i = _k = 0, _ref3 = this.idx; 0 <= _ref3 ? _k < _ref3 : _k > _ref3; i = 0 <= _ref3 ? ++_k : --_k) {
          f = (this.values[i] - min) / diff;
          left = (this.width - this.idx) + i;
          this.ctx.lineTo(left, (this.height - 2) * f + 1);
        }
      } else {
        this.ctx.moveTo(0, this.height / 2);
        this.ctx.lineTo(this.width, this.height / 2);
      }
      return this.ctx.stroke();
    };

    return Graph;

  })();

  window.WebGLPerfContext = {
    create: function(gl) {
      var bufferBinds, draws, frameEnd, frameStart, frameTime, jsTime, keydown, last, overlay, programs, shown, stopCount, vertices;
      frameStart = frameEnd = last = performance.now();
      overlay = element(document.body, 'div', {
        position: 'fixed',
        top: '0px',
        left: '0px',
        width: '100%',
        color: 'white',
        fontFamily: 'monospace',
        background: 'linear-gradient(to bottom, rgba(0,0,0,0.9) 0%,rgba(0,0,0,0.5) 100%)',
        borderBottom: '1px solid rgba(0,0,0,0.9)',
        pointerEvents: 'none',
        zIndex: '1000',
        display: 'none'
      });
      shown = false;
      keydown = function(event) {
        if (event.which === 192 || event.which === 191) {
          if (overlay.style.display.length === 0) {
            shown = false;
            return overlay.style.display = 'none';
          } else {
            shown = true;
            return overlay.style.display = '';
          }
        }
      };
      window.addEventListener('keydown', keydown, false);
      jsTime = new Graph('JS Execution Time (ms)', overlay);
      frameTime = new Graph('Frame Time (ms)', overlay);
      bufferBinds = new Graph('gl.bufferBind (count)', overlay);
      gl.origBindBuffer = gl.bindBuffer;
      gl.bindBuffer = function(target, buffer) {
        bufferBinds.counter += 1;
        return gl.origBindBuffer(target, buffer);
      };
      draws = new Graph('gl.draw* (count)', overlay);
      vertices = new Graph('gl.draw* (vertices)', overlay);
      gl.origDrawArrays = gl.drawArrays;
      gl.drawArrays = function(mode, first, count) {
        draws.counter += 1;
        vertices.counter += count;
        return gl.origDrawArrays(mode, first, count);
      };
      programs = new Graph('gl.useProgram (count)', overlay);
      gl.origUseProgram = gl.useProgram;
      gl.useProgram = function(program) {
        programs.counter += 1;
        return gl.origUseProgram(program);
      };
      stopCount = 0;
      gl.performance = {
        start: function() {
          bufferBinds.counter = 0;
          draws.counter = 0;
          vertices.counter = 0;
          programs.counter = 0;
          return frameStart = performance.now();
        },
        stop: function() {
          var frameDelta, jsDelta;
          stopCount += 1;
          frameEnd = performance.now();
          jsDelta = frameEnd - frameStart;
          frameDelta = frameEnd - last;
          last = frameEnd;
          jsTime.add(jsDelta);
          frameTime.add(frameDelta);
          bufferBinds.add();
          draws.add();
          vertices.add();
          programs.add();
          jsTime.draw();
          frameTime.draw();
          bufferBinds.draw();
          draws.draw();
          vertices.draw();
          return programs.draw();
        }
      };
      return gl;
    }
  };

}).call(this);
